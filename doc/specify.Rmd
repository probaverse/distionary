---
title: "Specify a Distribution"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Specify a distribution}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(distionary)
```


## Built-In Distribution Families

Here are the distributions and the corresponding `distionary` functions:  

| Distribution                     | `distionary` Function  |  Has counterpart in `stats` |
|----------------------------------|------------------------|-----------------------------|
| Bernoulli | `dst_bern()` | Yes |
| Beta | `dst_beta()` | Yes |
| Binomial | `dst_binom()` | Yes |
| Cauchy | `dst_cauchy()` | Yes |
| Chi Squared | `dst_chisq()` | Yes |
| Degenerate | `dst_degenerate()` | No |
| Exponential | `dst_exp()` | Yes |
| F | `dst_f()` | Yes |
| Gamma | `dst_gamma()` | Yes |
| Geometric | `dst_geom()` | Yes |
| Generalised Extreme Value (GEV) | `dst_gev()` | No |
| Generalised Pareto (GPD) | `dst_gpd()` | No |
| Hypergeometric | `dst_hyper()` | Yes |
| Log Normal | `dst_lnorm()` | Yes |
| Log Pearson Type III | `dst_lp3()` | No |
| Negative Binomial | `dst_nbinom()` | Yes |
| Normal | `dst_norm()` | Yes |
| Pearson Type III | `dst_pearson3()` | No |
| Poisson | `dst_pois()` | Yes |
| Student _t_ | `dst_t()` | Yes |
| Uniform | `dst_unif()` | Yes |
| Weibull | `dst_weibull()` | Yes |

In addition, there is a special "Null" distribution object akin to a missing or unknown distribution. This is useful, for example, if an algorithm fails to return a distribution: instead of throwing an error, a Null distribution can be returned.

```{r}
# Make a Null distribution.
null <- dst_null()
# Inspect
null
```

A Null distribution always evaluates to NA:

```{r}
mean(null)
eval_pmf(null, at = 1:4)
```

Distributions with a counterpart in the `stats` package use the same functions from the package and the same parameterisation. For instance, take a look at the source code defining the Normal distribution to see that the representations wrap the `stats::*norm()` family of functions.

```{r}
dst_norm
```

`distionary` also makes other distribution families available that are not found in the `stats` package.

## User-Defined Distributions

You can make your own distribution object using the `distribution()` function. Provide it with name-value pairs that can be stored with the object. Some names have a special interpretation in `distionary` in that they can be used in the calculation of other non-specified properties. These are:

- Any representation `*` invoked by `eval_*()` (e.g., `quantile` for `eval_quantile()`).
- Any property (e.g., `mean` for `mean()`)

See the [Evaluate a Distribution] vignette for more details on these evaluation functions.

For this version of `distionary`, it is mandatory to specify at least `cdf`. For continuous distributions, `density` is also mandatory, and for discrete, `pmf`.

Optionally, you can also specify a `parameters` object, which should be a named list of parameters that define the distribution. These parameters are never referred to by the distribution for its calculations, but are sometimes useful to keep track of for analysis.

Here is an example.

```{r}
# Make a continuous distribution
linear <- distribution(
  parameters = list(a = 1),
  density = function(x) {
    d <- 2 * (1 - x)
    d[x < 0 | x > 1] <- 0
    d
  },
  cdf = function(x) {
    p <- 2 * x * (1 - x / 2)
    p[x < 0] <- 0
    p[x > 1] <- 1
    p
  },
  g = 9.81,
  another_representation = function(x) x^2,
  .vtype = "continuous",
  .name = "My Linear"
)
# Inspect
linear
```

The usual evaluation framework can now be accessed. For example, the CDF and mean can be evaluated, even though the mean has not been specified.

```{r}
eval_cdf(linear, at = c(0.2, 0.5, 0.7))
mean(linear)
```

These quantities can be invoked by the more general function `eval_property()`.

```{r}
eval_property(linear, "cdf", c(0.2, 0.5, 0.7))
eval_property(linear, "mean")
```

`eval_property()` is a useful function for accessing quantities that are not built-in to `distionary`, like `g` and `another_representation` in this example.

```{r}
eval_property(linear, "another_representation", 1:4)
eval_property(linear, "g")
```






